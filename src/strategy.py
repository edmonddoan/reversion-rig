"""
Mean Reversion Trading Strategy Implementation.

This module contains the core MeanReversionStrategy class that implements
the trading logic based on technical indicators like Bollinger Bands, RSI,
and Z-score for identifying mean reversion opportunities.
"""

import pandas as pd
import numpy as np
from dataclasses import dataclass, field
from typing import Optional, Dict, Any, List
from enum import Enum

from .indicators import (
    calculate_all_indicators,
    bollinger_bands,
    rsi,
    zscore,
    sma,
)


class Position(Enum):
    """Position state enumeration."""
    NONE = 0
    LONG = 1
    SHORT = 2


@dataclass
class Trade:
    """Represents a single trade."""
    entry_date: pd.Timestamp
    entry_price: float
    exit_date: pd.Timestamp
    exit_price: float
    position: Position
    quantity: int
    pnl: float
    pnl_pct: float
    holding_period: int  # Days
    
    def __post_init__(self):
        if self.position == Position.LONG:
            self.pnl = (self.exit_price - self.entry_price) * self.quantity
            self.pnl_pct = (self.exit_price - self.entry_price) / self.entry_price
        else:  # SHORT
            self.pnl = (self.entry_price - self.exit_price) * self.quantity
            self.pnl_pct = (self.entry_price - self.exit_price) / self.entry_price
        
        self.holding_period = (self.exit_date - self.entry_date).days


@dataclass
class Signal:
    """Trading signal generated by the strategy."""
    date: pd.Timestamp
    signal: str  # 'BUY', 'SELL', 'HOLD'
    price: float
    reason: str
    indicators: Dict[str, float] = field(default_factory=dict)


class MeanReversionStrategy:
    """
    Mean Reversion Trading Strategy.
    
    This strategy capitalizes on price deviations from a moving average.
    Key signals:
    - BUY when price falls below lower Bollinger Band or RSI is oversold
    - SELL when price rises above upper Bollinger Band or RSI is overbought
    - Exit positions on stop-loss or take-profit levels
    
    Attributes:
        sma_period: Period for Simple Moving Average
        bb_period: Period for Bollinger Bands
        bb_std: Standard deviation multiplier for bands
        rsi_period: Period for RSI calculation
        rsi_oversold: RSI level considered oversold
        rsi_overbought: RSI level considered overbought
        stop_loss_pct: Stop loss percentage
        take_profit_pct: Take profit percentage
        position_size_pct: Position size as percentage of capital
        zscore_window: Window for Z-score calculation
    """
    
    def __init__(
        self,
        sma_period: int = 20,
        bb_period: int = 20,
        bb_std: float = 2.0,
        rsi_period: int = 14,
        rsi_oversold: float = 30.0,
        rsi_overbought: float = 70.0,
        stop_loss_pct: float = 0.05,
        take_profit_pct: float = 0.10,
        position_size_pct: float = 0.20,
        zscore_window: int = 20,
        use_zscore: bool = False,
        use_rsi: bool = True,
        min_confidence: float = 0.5,
    ):
        """Initialize the mean reversion strategy."""
        self.sma_period = sma_period
        self.bb_period = bb_period
        self.bb_std = bb_std
        self.rsi_period = rsi_period
        self.rsi_oversold = rsi_oversold
        self.rsi_overbought = rsi_overbought
        self.stop_loss_pct = stop_loss_pct
        self.take_profit_pct = take_profit_pct
        self.position_size_pct = position_size_pct
        self.zscore_window = zscore_window
        self.use_zscore = use_zscore
        self.use_rsi = use_rsi
        self.min_confidence = min_confidence
        
        # State
        self.position: Position = Position.NONE
        self.entry_price: float = 0.0
        self.entry_date: Optional[pd.Timestamp] = None
        self.quantity: int = 0
        self.trades: List[Trade] = []
        self.signals: List[Signal] = []
    
    def __repr__(self) -> str:
        return (
            f"MeanReversionStrategy(sma={self.sma_period}, "
            f"bb_period={self.bb_period}, bb_std={self.bb_std}, "
            f"rsi_period={self.rsi_period}, "
            f"stop_loss={self.stop_loss_pct:.1%}, "
            f"take_profit={self.take_profit_pct:.1%})"
        )
    
    def calculate_indicators(self, df: pd.DataFrame, price_col: str = "close") -> pd.DataFrame:
        """
        Calculate all required indicators for the strategy.
        
        Args:
            df: DataFrame with price data
            price_col: Name of the price column
            
        Returns:
            DataFrame with indicators added
        """
        return calculate_all_indicators(
            df,
            price_col=price_col,
            sma_period=self.sma_period,
            ema_period=self.sma_period,
            rsi_period=self.rsi_period,
            bb_period=self.bb_period,
            bb_std=self.bb_std,
            zscore_window=self.zscore_window
        )
    
    def generate_signal(
        self, 
        row: pd.Series,
        confidence: float = 0.5
    ) -> Signal:
        """
        Generate a trading signal based on current indicators.
        
        Args:
            row: Row with price and indicator data
            confidence: Signal confidence level
            
        Returns:
            Signal object
        """
        price = row.get("Close", row.get("close", 0))
        bb_upper = row.get("BB_Upper", price)
        bb_lower = row.get("BB_Lower", price)
        bb_position = row.get("BB_Position", 0.5)
        rsi_val = row.get(f"RSI_{self.rsi_period}", 50)
        zscore_val = row.get(f"ZScore_{self.zscore_window}", 0)
        
        # Initialize signal
        signal_type = "HOLD"
        reason = "No clear signal"
        
        if self.position == Position.NONE:
            # Look for entry signals
            buy_conditions = []
            sell_conditions = []
            
            # Bollinger Band conditions
            if price < bb_lower:
                buy_conditions.append("Price below lower Bollinger Band")
            if price > bb_upper:
                sell_conditions.append("Price above upper Bollinger Band")
            
            # RSI conditions
            if self.use_rsi:
                if rsi_val < self.rsi_oversold:
                    buy_conditions.append(f"RSI oversold ({rsi_val:.1f})")
                if rsi_val > self.rsi_overbought:
                    sell_conditions.append(f"RSI overbought ({rsi_val:.1f})")
            
            # Z-score conditions
            if self.use_zscore:
                if zscore_val < -2.0:
                    buy_conditions.append(f"Z-score oversold ({zscore_val:.2f})")
                if zscore_val > 2.0:
                    sell_conditions.append(f"Z-score overbought ({zscore_val:.2f})")
            
            # Determine signal
            if len(buy_conditions) > 0 and confidence >= self.min_confidence:
                signal_type = "BUY"
                reason = " | ".join(buy_conditions)
            elif len(sell_conditions) > 0 and confidence >= self.min_confidence:
                signal_type = "SELL"
                reason = " | ".join(sell_conditions)
        
        elif self.position == Position.LONG:
            # Look for exit signals
            exit_reason = None
            
            # Stop loss
            if price <= self.entry_price * (1 - self.stop_loss_pct):
                signal_type = "SELL"
                exit_reason = f"Stop loss triggered ({self.stop_loss_pct:.1%} below entry)"
            
            # Take profit
            elif price >= self.entry_price * (1 + self.take_profit_pct):
                signal_type = "SELL"
                exit_reason = f"Take profit hit ({self.take_profit_pct:.1%} above entry)"
            
            # Mean reversion exit (price returned to mean)
            elif price >= bb_upper or rsi_val > self.rsi_overbought:
                signal_type = "SELL"
                exit_reason = "Mean reversion complete (price at upper band)"
            
            if exit_reason:
                reason = exit_reason
        
        return Signal(
            date=row.name if hasattr(row, 'name') else pd.Timestamp.now(),
            signal=signal_type,
            price=price,
            reason=reason,
            indicators={
                "bb_position": bb_position,
                "rsi": rsi_val,
                "zscore": zscore_val,
                "confidence": confidence
            }
        )
    
    def run_strategy(
        self,
        df: pd.DataFrame,
        initial_capital: float = 100000.0,
        price_col: str = "close"
    ) -> Dict[str, Any]:
        """
        Run the mean reversion strategy on historical data.
        
        Args:
            df: DataFrame with price data
            initial_capital: Starting capital for backtest
            price_col: Name of the price column
            
        Returns:
            Dictionary with backtest results
        """
        # Prepare data with indicators
        data = self.calculate_indicators(df.copy(), price_col)
        
        # Initialize tracking
        capital = initial_capital
        self.position = Position.NONE
        self.entry_price = 0.0
        self.entry_date = None
        self.quantity = 0
        self.trades = []
        self.signals = []
        
        # Track portfolio value over time
        portfolio_values = []
        positions = []
        
        for idx, row in data.iterrows():
            price = row[price_col]
            signal = self.generate_signal(row)
            self.signals.append(signal)
            
            # Execute trades
            if signal.signal == "BUY" and self.position == Position.NONE:
                # Calculate position size
                position_value = capital * self.position_size_pct
                self.quantity = int(position_value / price)
                self.entry_price = price
                self.entry_date = idx
                self.position = Position.LONG
                capital -= self.quantity * price
            
            elif signal.signal == "SELL" and self.position == Position.LONG:
                # Close position
                capital += self.quantity * price
                pnl = (price - self.entry_price) * self.quantity
                
                trade = Trade(
                    entry_date=self.entry_date,
                    entry_price=self.entry_price,
                    exit_date=idx,
                    exit_price=price,
                    position=Position.LONG,
                    quantity=self.quantity,
                    pnl=pnl,
                    pnl_pct=(price - self.entry_price) / self.entry_price,
                    holding_period=0
                )
                self.trades.append(trade)
                
                self.position = Position.NONE
                self.quantity = 0
                self.entry_price = 0.0
                self.entry_date = None
            
            # Track portfolio value
            if self.position == Position.LONG:
                portfolio_value = capital + (self.quantity * price)
            else:
                portfolio_value = capital
            
            portfolio_values.append(portfolio_value)
            positions.append(self.position.value)
        
        # Close any open position at the end
        if self.position == Position.LONG:
            last_price = data[price_col].iloc[-1]
            capital += self.quantity * last_price
            
            trade = Trade(
                entry_date=self.entry_date,
                entry_price=self.entry_price,
                exit_date=data.index[-1],
                exit_price=last_price,
                position=Position.LONG,
                quantity=self.quantity,
                pnl=(last_price - self.entry_price) * self.quantity,
                pnl_pct=(last_price - self.entry_price) / self.entry_price,
                holding_period=0
            )
            self.trades.append(trade)
        
        # Calculate metrics
        portfolio_series = pd.Series(portfolio_values, index=data.index)
        returns = portfolio_series.pct_change().dropna()
        
        # Build results
        results = {
            "portfolio_values": portfolio_series,
            "positions": pd.Series(positions, index=data.index),
            "trades": self.trades,
            "signals": self.signals,
            "final_capital": capital,
            "total_return": (capital - initial_capital) / initial_capital,
            "num_trades": len(self.trades),
            "win_rate": len([t for t in self.trades if t.pnl > 0]) / len(self.trades) if self.trades else 0,
            "avg_win": np.mean([t.pnl for t in self.trades if t.pnl > 0]) if [t for t in self.trades if t.pnl > 0] else 0,
            "avg_loss": np.mean([t.pnl for t in self.trades if t.pnl < 0]) if [t for t in self.trades if t.pnl < 0] else 0,
            "returns": returns,
        }
        
        return results
    
    def get_parameters(self) -> Dict[str, Any]:
        """Get strategy parameters as dictionary."""
        return {
            "sma_period": self.sma_period,
            "bb_period": self.bb_period,
            "bb_std": self.bb_std,
            "rsi_period": self.rsi_period,
            "rsi_oversold": self.rsi_oversold,
            "rsi_overbought": self.rsi_overbought,
            "stop_loss_pct": self.stop_loss_pct,
            "take_profit_pct": self.take_profit_pct,
            "position_size_pct": self.position_size_pct,
            "zscore_window": self.zscore_window,
            "use_zscore": self.use_zscore,
            "use_rsi": self.use_rsi,
            "min_confidence": self.min_confidence,
        }


def create_strategy(**kwargs) -> MeanReversionStrategy:
    """
    Factory function to create a MeanReversionStrategy.
    
    Args:
        **kwargs: Strategy parameters
        
    Returns:
        Configured MeanReversionStrategy instance
    """
    return MeanReversionStrategy(**kwargs)
